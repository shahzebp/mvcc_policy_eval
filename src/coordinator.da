import sys

import queue

import logging
import logging.handlers
import logging.config

from time import sleep
from threading import Thread
from collections import deque
from datetime import datetime
import time

from worker import Worker
from common import Request, Response

class Coordinator(process):

    def setup(coordinators, database, config  ):
        
        self.logger = logging.getLogger('sLogger')

        self.exit = False
        
        main_cache = {}

        self.send_sequence  = 1
        self.recv_sequence  = 1

        self.PCA = {}

        self.maxdblatency   = int(config.get("setup", "maxdblatency"))
        
        # Each coordinator intantiates its own workers
        # It is one as of now

        self.worker     = new(Worker, num = 1)
        setup(self.worker, (coordinators, database, config))
        start(worker)

    def run():

        # Await till exit is issued by the master 
        await(received(('EXIT',)))
            
        logger.info("Exiting the Coordinators")
        # Issue await to the clients
        send(('EXIT',), to=(worker))

    # Initial process when request is received.
    # This is also the point of start for restart
    def entrypoint(request):

        request.timestamp   = time.time()

        logger.info("[object1 Coord] Sending request (UUID: {0}) to object2 Coord"
            .format(request.uuid))
        logger.debug("[object1 Coord] Sending request (seq. {0}) to object2 Coord: {1}"
            .format(send_sequence, request))

        send_sequence =  send_sequence + 1
        
        coordinator_id = 0

        to_writeObj = len(request.mightWriteObj)

        if(to_writeObj == 0 or to_writeObj == 2):
            coordinator_id = request.object2_id % len(coordinators)
        else:
            coordinator_id = request.mightWriteObj[0] % len(coordinators)
            
        send(('FROM_COORD_REQUEST', request), to=(coordinators[coordinator_id]))

    # Receive the request from the client
    def receive(msg=('FROM_CLIENT', request), from_=p):
        
        logger.info("[Coord 1] Request received (UUID: {0}) from Client"
            .format(request.uuid))
        logger.debug("[Coord 1] Request received (seq. {0}) from Client: {1}"
            .format(recv_sequence, request))
        
        recv_sequence = recv_sequence + 1
        
        request.owner = p
        
        entrypoint(request)
    
    # Receive the request from object1 coordinator
    def receive(msg=('FROM_COORD_REQUEST', request), from_=p):
        
        logger.info("[object2 Coord] Request received (UUID: {0}) from object1 Coord"
            .format(request.uuid))
        logger.debug("[object2 Coord] Request received (seq. {0}) from object1 Coord {1}"
            .format(recv_sequence, request))

        recv_sequence = recv_sequence + 1

        logger.info("[object2 Coord] Sending request (UUID: {0}) to Worker"
            .format(request.uuid))
        logger.debug("[object2 Coord] Sending request (seq. {0}) to Worker: {1}"
            .format(send_sequence, request))

        send_sequence =  send_sequence + 1
        
        send(('FROM_COORD', request), to = (worker))

    def receive(msg=('FROM_COORD_2_RESPONSE', response), from_=p):
        pass

    # object1 cooridinator receives response from the worker
    # This response is the evaluation result for the request
    # There exists a compostion of request inside response
    def receive(msg=('FROM_WORKER_RESPONSE', response), from_=p):

        # Sending the message to the 1st corordinator in case this was a write request
        if(response.request.read_only == False):
            send(('FROM_COORD_2_RESPONSE', response), to = (coordinators[0]))
            send(('OUTCOME', response), to = (response.request.client))
        
        logger.info("[object1 Coord] Response received (UUID. {0}) from Worker"
            .format(response.request.uuid))
        logger.debug("[object1 Coord] Response received (seq. {0}) from Worker: {1}"
            .format(recv_sequence, response))
        
        recv_sequence = recv_sequence + 1