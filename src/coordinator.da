import sys

import queue
import uuid
import collections

import logging
import logging.handlers
import logging.config

from time import sleep
from threading import Thread
from collections import deque
from datetime import datetime
import time

from worker import Worker
from common import Request, Response, Version

class Coordinator(process):

    def setup(coordinators, database, config  ):
        
        self.logger = logging.getLogger('sLogger')

        self.exit = False
        
        self.main_cache = {}

        self.send_sequence  = 1
        self.recv_sequence  = 1

        self.session_id = uuid.uuid4()

        self.PCA = {}

        self.maxdblatency   = int(config.get("setup", "maxdblatency"))
        
        # Each coordinator intantiates its own workers
        # It is one as of now

        self.worker     = new(Worker, num = 1)
        setup(self.worker, (coordinators, database, config))
        start(worker)

    def run():

        # Await till exit is issued by the master 
        await(received(('EXIT',)))
            
        logger.info("Exiting the Coordinators")
        # Issue await to the clients
        send(('EXIT',), to=(worker))

    def latestVersionBefore(id, attr, ts):
        version = None

        if id not in main_cache:
            main_cache[id] = {}

        if attr not in main_cache[id]:
            main_cache[id][attr] = []

        if len(main_cache[id][attr]) > 0:
            for v in reversed(main_cache[id][attr]):
                if v.wts < ts:
                    version = v
                    break
        else:
            version = Version(attr, None)
            main_cache[id][attr].append(version)

        return version

    def cachedUpdates(id, curr_object, request):
        cachedResults = []
        attrList = (request.defReadAttr[curr_object] + request.mightReadAttr[curr_object])

        for attr in attrList:
            cachedResults.append(latestVersionBefore(id, attr, request.timestamp))

        return cachedResults

    def restart(response):
        coordinator_id = response.read_only_object % len(coordinators)    
        send(('FROM_RESTART', response.request), to = (coordinators[coordinator_id]))


    # Initial process when request is received.
    # This is also the point of start for restart
    def entrypoint(request):

        request.timestamp   = time.time()

        logger.info("[Coord {0}] Sending request (UUID: {1}) to object {2} Coord"
            .format(request.swapped, request.uuid, int(not request.swapped)))
        logger.debug("[Coord {0}] Sending request (seq. {1}) to object {2} Coord: {3}"
            .format(request.swapped, send_sequence, int(not request.swapped), request))

        curr_object = request.swapped

        if (request.read_only):
            for attr in request.defReadAttr[curr_object]:
                latestVersionBefore(request.object[curr_object], attr, request.timestamp).rts = request.timestamp

            for attr in request.mightReadAttr[curr_object]:
                v = latestVersionBefore(request.object[curr_object], attr, request.timestamp)
                v.pendingMightRead.append(request.uuid)

        else:
            for attr in (request.defReadAttr[curr_object] + request.mightReadAttr[curr_object]):
                v = latestVersionBefore(request.object[curr_object], attr, request.timestamp)
                v.pendingMightRead.append(request.uuid)
        
        request.cached_updates[curr_object] = cachedUpdates(request.object[curr_object], curr_object, request)

        # send this to next coordinator
        send_sequence =  send_sequence + 1
        
        
        # Need to send to appropriate coordinator
        coordinator_id = 0

        if (request.swapped == 0):
            coordinator_id = request.object[1] % len(coordinators)
        else:
            coordinator_id = request.object[0] % len(coordinators)
            
        send(('FROM_COORD_REQUEST', request), to=(coordinators[coordinator_id]))
        

    # Receive the request from the client
    def receive(msg=('FROM_CLIENT', request), from_=p):
        
        logger.info("[Coord {0}] Request received (UUID: {1}) from Client"
            .format(request.swapped, request.uuid))
        logger.debug("[Coord {0}] Request received (seq. {1}) from Client: {2}"
            .format(request.swapped, recv_sequence, request))
        
        recv_sequence = recv_sequence + 1
        
        request.owner = p
        
        entrypoint(request)
    
    def receive(msg=('FROM_RESTART', request), from_=p):
        
        logger.info("[Coord {0}] Request received (UUID: {1}) from Client"
            .format(request.swapped, request.uuid))
        logger.debug("[Coord {0}] Request received (seq. {1}) from Client: {2}"
            .format(request.swapped, recv_sequence, request))
        
        recv_sequence = recv_sequence + 1
        
        entrypoint(request)

    # Receive the request from object1 coordinator
    def receive(msg=('FROM_COORD_REQUEST', request), from_=p):
        
        logger.info("[Coord {0}] Request received (UUID: {1}) from object {2} Coord"
            .format(int(not request.swapped), request.uuid, request.swapped))
        logger.debug("[Coord {0}] Request received (seq. {1}) from object {2} Coord {3}"
            .format(int(not request.swapped), recv_sequence, request.swapped, request))

        recv_sequence = recv_sequence + 1

        curr_object = 1

        if (request.swapped == 1):
            curr_object = 0

        if (request.read_only):
            for attr in request.defReadAttr[curr_object]:
                latestVersionBefore(request.object[curr_object], attr, request.timestamp).rts = request.timestamp

            for attr in request.mightReadAttr[curr_object]:
                v = latestVersionBefore(request.object[curr_object], attr, request.timestamp)
                v.pendingMightRead.append(request.uuid)

        else:
            for attr in (request.defReadAttr[curr_object] + request.mightReadAttr[curr_object]):
                v = latestVersionBefore(request.object[curr_object], attr, request.timestamp)
                v.pendingMightRead.append(request.uuid)

        request.cached_updates[curr_object] = cachedUpdates(request.object[curr_object], curr_object, request)

        logger.info("[object{0} Coord] Sending request (UUID: {1}) to Worker"
            .format(int(not request.swapped), request.uuid))
        logger.debug("[object{0} Coord] Sending request (seq. {1}) to Worker: {2}"
            .format(int(not request.swapped), send_sequence, request))

        send_sequence =  send_sequence + 1
        
        send(('FROM_COORD', request), to = (worker))


    # object1 cooridinator receives response from the worker
    # This response is the evaluation result for the request
    # There exists a compostion of request inside response
    def receive(msg=('FROM_WORKER_READATTR', response, i), from_=p):

        logger.info("[Coord] Response received (UUID. {0}) from Worker"
            .format(response.request.uuid))
        logger.debug("[Coord] Response received (seq. {0}) from Worker: {1}"
            .format(recv_sequence, response))
        recv_sequence = recv_sequence + 1

        for attr in response.request.mightReadAttr[i]:
            v = latestVersionBefore(response.request.object[i], attr, response.request.timestamp)
            v.pendingMightRead.remove(response.request.uuid)

            if attr in response.readAttr[i]:
                v.rts = response.request.timestamp

    def check_conflicts(response):
        updated_object = response.updated_object

        for key in response.updates:
            v = latestVersionBefore(updated_object, key, response.request.timestamp)
            if v.rts > response.request.timestamp:
                return True

        return False

    def update_cache(response):
        pass

    def check_PMR_empty(response):
        return True


    # object1 cooridinator receives response from the worker
    # This response is the evaluation result for the request
    # There exists a compostion of request inside response
    def receive(msg=('FROM_WORKER_RESPONSE', response), from_=p):

        #TODO check session id. if not equal then return

        logger.info("[object1 Coord] Response received (UUID. {0}) from Worker"
            .format(response.request.uuid))
        logger.debug("[object1 Coord] Response received (seq. {0}) from Worker: {1}"
            .format(recv_sequence, response))
        
        recv_sequence = recv_sequence + 1

        conflict = check_conflicts(response)

        if conflict == False:
            if response.updated_object not in PCA:
                PCA[response.updated_object] = {}

            for key in response.updates:
                if key not in PCA[response.updated_object]:
                    PCA[response.updated_object][key] = []

                PCA[response.updated_object][key].append(response.request.uuid)

            await(check_PMR_empty(response) == True)

            i_conflict = check_conflicts(response)

            if i_conflict == False:
                # TODO send updates to DB

                update_cache(response)

                updated_object_index = 0
                if (response.request.object[1] == response.updated_object):
                    updated_object_index = 1


                attr_list = (response.request.defReadAttr[updated_object_index] +
                            response.request.mightReadAttr[updated_object_index])

                for attr in attr_list:
                    v = latestVersionBefore(response.updated_object, attr, response.request.timestamp)
                    v.pendingMightRead.remove(response.uuid)

                    if attr in response.readAttr:
                        v.rts = response.request.timestamp

                send(('OUTCOME', response), to = (response.request.client))
                
                coordinator_id = response.read_only_object % len(coordinators)    
                send(('FROM_WORKER_READATTR', response, 0), to = (coordinators[coordinator_id]))

                for key in response.updates:
                    PCA[response.updated_object][key].remove(response.request.uuid)
            else:
                for key in response.updates:
                    PCA[response.updated_object][key].remove(response.request.uuid)

                restart(response)
        else:
            restart(response)


