import sys

import queue
import uuid
import collections

import logging
import logging.handlers
import logging.config

from time import sleep
from threading import Thread
from collections import deque
from datetime import datetime
import time

from worker import Worker
from common import Request, Response, Version

class Coordinator(process):

    def setup(coordinators, database, config  ):
        
        self.logger = logging.getLogger('sLogger')

        self.exit = False
        
        self.main_cache = {}

        self.send_sequence  = 1
        self.recv_sequence  = 1

        self.session_id = uuid.uuid4()

        self.PCA = {}

        self.maxdblatency   = int(config.get("setup", "maxdblatency"))
        
        # Each coordinator intantiates its own workers
        # It is one as of now

        self.worker     = new(Worker, num = 1)
        setup(self.worker, (coordinators, database, config))
        start(worker)

    def run():

        # Await till exit is issued by the master 
        await(received(('EXIT',)))
            
        logger.info("Exiting the Coordinators")
        # Issue await to the clients
        send(('EXIT',), to=(worker))

    def latestVersionBefore(id, attr, ts):
        version = None

        if id not in main_cache:
            main_cache[id] = {}

        if attr not in main_cache[id]:
            main_cache[id][attr] = []

        if len(main_cache[id][attr]) > 0:
            for v in reversed(main_cache[id][attr]):
                if v.wts < ts:
                    version = v
                    break
        else:
            version = Version(attr, None)
            main_cache[id][attr].append(version)

        return version

    def cachedUpdates(id, curr_object, request):
        cachedResults = []
        attrList = (request.defReadAttr[curr_object] + request.mightReadAttr[curr_object])

        for attr in attrList:
            cachedResults.append(latestVersionBefore(id, attr, request.timestamp))

        return cachedResults


    # Initial process when request is received.
    # This is also the point of start for restart
    def entrypoint(request):

        request.timestamp   = time.time()

        logger.info("[Coord {0}] Sending request (UUID: {1}) to object {2} Coord"
            .format(request.swapped, request.uuid, int(not request.swapped)))
        logger.debug("[Coord {0}] Sending request (seq. {1}) to object {2} Coord: {3}"
            .format(request.swapped, send_sequence, int(not request.swapped), request))

        curr_object = request.swapped

        if (request.read_only):
            for attr in request.defReadAttr[curr_object]:
                latestVersionBefore(request.object[curr_object], attr, request.timestamp).rts = request.timestamp

            for attr in request.mightReadAttr[curr_object]:
                v = latestVersionBefore(request.object[curr_object], attr, request.timestamp)
                v.pendingMightWrite.append((request.uuid, request.timestamp))

        else:
            for attr in (request.defReadAttr[curr_object] + request.mightReadAttr[curr_object]):
                v = latestVersionBefore(request.object[curr_object], attr, request.timestamp)
                v.pendingMightWrite.append((request.uuid, request.timestamp))
        
        request.cached_updates[curr_object] = cachedUpdates(request.object[curr_object], curr_object, request)

        # send this to next coordinator
        send_sequence =  send_sequence + 1
        
        
        # Need to send to appropriate coordinator
        coordinator_id = 0

        if (request.swapped == 0):
            coordinator_id = request.object[1] % len(coordinators)
        else:
            coordinator_id = request.object[0] % len(coordinators)
            
        send(('FROM_COORD_REQUEST', request), to=(coordinators[coordinator_id]))
        

    # Receive the request from the client
    def receive(msg=('FROM_CLIENT', request), from_=p):
        
        logger.info("[Coord {0}] Request received (UUID: {1}) from Client"
            .format(request.swapped, request.uuid))
        logger.debug("[Coord {0}] Request received (seq. {1}) from Client: {2}"
            .format(request.swapped, recv_sequence, request))
        
        recv_sequence = recv_sequence + 1
        
        request.owner = p
        
        entrypoint(request)
    
    # Receive the request from object1 coordinator
    def receive(msg=('FROM_COORD_REQUEST', request), from_=p):
        
        logger.info("[object{0} Coord] Request received (UUID: {1}) from object {2} Coord"
            .format(int(not request.swapped), request.uuid, request.swapped))
        logger.debug("[object{0} Coord] Request received (seq. {1}) from object {2} Coord {3}"
            .format(int(not request.swapped), recv_sequence, request.swapped, request))

        recv_sequence = recv_sequence + 1

        curr_object = 1

        if (request.swapped == 1):
            curr_object = 0

        if (request.read_only):
            for attr in request.defReadAttr[curr_object]:
                latestVersionBefore(request.object[curr_object], attr, request.timestamp).rts = request.timestamp

            for attr in request.mightReadAttr[curr_object]:
                v = latestVersionBefore(request.object[curr_object], attr, request.timestamp)
                v.pendingMightWrite.append((request.uuid, request.timestamp))

        else:
            for attr in (request.defReadAttr[curr_object] + request.mightReadAttr[curr_object]):
                v = latestVersionBefore(request.object[curr_object], attr, request.timestamp)
                v.pendingMightWrite.append((request.uuid, request.timestamp))

        request.cached_updates[curr_object] = cachedUpdates(request.object[curr_object], curr_object, request)

        logger.info("[object{0} Coord] Sending request (UUID: {1}) to Worker"
            .format(int(not request.swapped), request.uuid))
        logger.debug("[object{0} Coord] Sending request (seq. {1}) to Worker: {2}"
            .format(int(not request.swapped), send_sequence, request))

        send_sequence =  send_sequence + 1
        
        send(('FROM_COORD', request), to = (worker))

    # object1 cooridinator receives response from the worker
    # This response is the evaluation result for the request
    # There exists a compostion of request inside response
    def receive(msg=('FROM_WORKER_RESPONSE', response), from_=p):

        # Sending the message to the 1st corordinator in case this was a write request
        if(response.request.read_only == False):
            send(('OUTCOME', response), to = (response.request.client))
        
        logger.info("[object1 Coord] Response received (UUID. {0}) from Worker"
            .format(response.request.uuid))
        logger.debug("[object1 Coord] Response received (seq. {0}) from Worker: {1}"
            .format(recv_sequence, response))
        
        recv_sequence = recv_sequence + 1