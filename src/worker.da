import xml.etree.ElementTree as ET
from common import Request, Response, Rule
from time import sleep
import logging
import logging.handlers
import logging.config

import operator

class Worker(process):
    def setup(coordinators, database, config):
        
        self.logger = logging.getLogger('sLogger')
        self.exit = False
        self.coordinators = coordinators
        self.policy_map = {}
        self.database = database
        self.send_sequence = 1
        self.recv_sequence = 1
        policy_file = config.get("setup", "policy_def_file")

        read_policy(policy_file)
        
    
    def read_policy(policy_xml):
        tree = ET.parse(policy_xml)
        root = tree.getroot()
        for rule in root.iter('rule'):
            sc=rule.find('object1Condition').attrib
            rc=rule.find('object2Condition').attrib
            act=rule.find('action').attrib
            su=rule.find('object1Update')
            if su != None:
                su = su.attrib
            ru=rule.find('object2Update')
            if ru != None:
                ru = ru.attrib

            rule_object = Rule(sc, rc, act, su, ru)

            """
            Adding the Rule object to the action map.
            So each action will have a list of Rule objects
            that satisfy that action.
            """
            if act["name"] in self.policy_map.keys():
                self.policy_map[act["name"]].append(rule_object)
            else:
                self.policy_map[act["name"]] = [rule_object]

    def run():
        await(received(('EXIT',)))
        #logger.info("Exiting the Workers")

    def receive(msg=('FROM_COORD', request), from_ = p):
        
        logger.info("[Worker] Receiving request (UUID: {0}) from Coordinator {1}"
            .format(request.uuid, int(not request.swapped)))
        logger.debug("[Worker] Receiving request (seq. {0}) from Coordinator {1}: {2}"
            .format(recv_sequence, int(not request.swapped), request))

        recv_sequence += 1

        logger.info("[Worker] Sending request (UUID: {0}) to Database Emulator"
            .format(request.uuid))
        logger.debug("[Worker] Sending request (seq. {0}) to Database Emulator: {1}"
            .format(send_sequence, request))
        send_sequence += 1

        send(('FROM_WORKER', request), to = (database))

    def receive(msg=('FROM_DATABASE', database_response), from_ = p):

        logger.info("[Worker] Receiving response (UUID: {0}) from Database Emulator"
            .format(database_response.request.uuid))
        logger.debug("[Worker] Receiving response (seq. {0}) from Database Emulator: {1}"
            .format(recv_sequence, database_response))
        
        recv_sequence += 1
        
        # If delay specified sleep for that while
        
        sleep(database_response.request.art_delay)

        response = Response(database_response.request, True)

        ## TODO dummy to updated object. Correct it properly
        response.updated_object = response.request.object[0]

        coordinator_id = 0

        if(response.updated_object == -1):
            send(('OUTCOME', response), to = (response.request.client))
            
            coordinator_id = response.request.object[0] % len(coordinators)    
            send(('FROM_WORKER_READATTR', response, 0), to = (coordinators[coordinator_id]))

            coordinator_id = response.request.object[1] % len(coordinators)    
            send(('FROM_WORKER_READATTR', response, 1), to = (coordinators[coordinator_id]))

        else:
            coordinator_id = response.updated_object % len(coordinators)
            send(('FROM_WORKER_RESPONSE', response), to = (coordinators[coordinator_id]))

        return